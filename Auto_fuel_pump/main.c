	/**********************************************************************************************
	*                                                                                             *
	*                  Автоматическая подкачка топлива перед запуском двигателя                   *
	*                                                                                             *
	*                                   ATtiny13A     0.6 MHz                                     *
	*                                                                                             *
	**********************************************************************************************/


	/**********************************************************************************************
	*                              ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ И ФУНКЦИЙ                                *
	**********************************************************************************************/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>

#define OUT					2					//PB2
#define LED					1					//PB1
#define BTN					0					//PB0
#define Pump_ON				PORTB |= (1<<OUT)
#define Pump_OFF			PORTB &=~ (1<<OUT)
#define Led_ON				PORTB |= (1<<LED)
#define Led_OFF				PORTB &=~ (1<<LED)
#define Delay_to_start		25														// задержка перед включением		25 / 25.5 Hz (из настроек таймера) = 1 сек.
#define Delay_btn			38														// задержка кнопки					38 / 25.5 Hz (из настроек таймера) = 1.5 сек.
#define _pump_is_on			0														// флаг включенного насоса (бит 0)
#define _pumping_is_done	1														// флаг законченной подкачки (бит 1)
#define _btn_pressed		2														// флаг нажатой кнопки (бит 2)
#define _setting_mode_on	3														// флаг активного режима настройки (бит 3)

volatile unsigned char	CountTime = 0;												// счетчик (инкрементируется по прерыванию А таймера)
volatile unsigned char	Flag_byte = 0;												// флаговая переменная
volatile unsigned char	Delay_Pump_ON;												// время работы насоса		Delay_Pump_ON / 25.5 Hz (из настроек таймера) = сек.
uint8_t		EEMEM		Delay_Pump_ON_EE;											// время работы насоса - переменная для EEPROM 

void Presets(void);


	/**********************************************************************************************
	*                                     ОСНОВНАЯ ФУНКЦИЯ                                        *
	**********************************************************************************************/

int main (void)
{
	Presets();

	while (1)
	{
		if ((Flag_byte & (1<<_setting_mode_on)) == 0)							//если не активен режим настройки
		{
			if (Delay_Pump_ON != 0)													// если задержка не нулевая
			{
				if ((Flag_byte == 0) && (CountTime >= Delay_to_start))				// если начало работы программы и закончено время задержки перед включением
				{
					asm("cli");
					Pump_ON;														// включение насоса
					Led_ON;
					Flag_byte |= (1<<_pump_is_on);									// установка флага
					CountTime = 0;													// обнуление счетчика
					asm("sei");
				}
		
				if ((Flag_byte & (1<<_pump_is_on)) && (CountTime >= Delay_Pump_ON))	// если насос включен и закончилось время работы
				{
					asm("cli");
					Pump_OFF;														// выключение насоса
					Led_OFF;
					Flag_byte &=~ (1<<_pump_is_on);									// снятие флага включенного насоса
					Flag_byte |= (1<<_pumping_is_done);								// установка флага законченной работы
					asm("sei");
				}
			}
		
			if (((PINB & (1<<BTN)) == 0) && ((Flag_byte & (1<<_btn_pressed)) == 0))	// если нажата кнопка (ранее не была нажата)
			{
				asm("cli");
				Pump_OFF;															// выключение насоса
				Led_OFF;
				Flag_byte &=~ (1<<_pump_is_on);										// снятие флага включенного насоса
				Flag_byte |= (1<<_pumping_is_done);									// установка флага законченной работы
				Flag_byte |= (1<<_btn_pressed);										// установка флага нажатой кнопки
				CountTime = 0;														// обнуление счетчика
				asm("sei");
			}
		
			if ((Flag_byte & (1<<_btn_pressed)) && (CountTime >= Delay_btn))		// если нажата кнопка и прошло время задержки кнопки
			{
				asm("cli");
				Pump_ON;															// включение насоса
				Led_ON;
				Flag_byte |= (1<<_pump_is_on);										// установка флага
				CountTime = Delay_btn;												// установка счетчика для постоянного срабатывания при нажатой кнопке
				asm("sei");
			}
		
			if ((PINB & (1<<BTN)) && (Flag_byte & (1<<_btn_pressed)))				// если кнопка не нажата, но была ранее нажата
			{
				asm("cli");
				Pump_OFF;															// выключение насоса
				Led_OFF;
				Flag_byte &=~ (1<<_pump_is_on);										// снятие флага включенного насоса
				Flag_byte |= (1<<_pumping_is_done);									// установка флага законченной работы
				Flag_byte &=~ (1<<_btn_pressed);									// сброс флага нажатой кнопки
				CountTime = 0;
				asm("sei");
			}
		} 
		
		if (Flag_byte & (1<<_setting_mode_on))									// если активен режим настройки
		{
			if ((PINB & (1<<BTN)) == 0)												// если нажата кнопка
			{
				if (CountTime >= 13)												// когда счетчик = 13 / 25.5 Hz (из настроек таймера) = 0,5 сек.
				{
					PORTB ^= (1<<LED);												// мигание светодиодом каждые 0.5 сек.
					CountTime = 0;
				}
			}
			else
			{
				asm("cli");
				Led_OFF;
				Flag_byte &=~ (1<<_setting_mode_on);
				if (Delay_Pump_ON < 15) Delay_Pump_ON = 0;
				eeprom_write_byte (& Delay_Pump_ON_EE, Delay_Pump_ON);
				Flag_byte = 0;
				asm("sei");
			}
		}
				
		asm("nop");
	}
}


	/**********************************************************************************************
	*                                    ОСТАЛЬНЫЕ ФУНКЦИИ                                        *
	**********************************************************************************************/

		/*-------------------------------- Предустановки ------------------------------------*/

void Presets (void)
{
	DDRB |= (1<<OUT) | (1<<LED);
	DDRB &=~ (1<<BTN);
	PORTB |= (1<<BTN);
	Pump_OFF;
	Led_OFF;
	
	TCCR0B 	|=	(1<<CS02) | (1<<CS00);												// установка предделителя таймера (табл. 11.9 стр. 74) 	600000/1024~=586 Hz
	TCCR0A 	|= 	(1<<WGM01);															// выбор режима работы таймера (табл. 11.8 стр. 73)		CTC
	TIMSK0 	|=	(1<<OCIE0A);														// прерывание по совпадению A (11.9.6 стр. 75)
	OCR0A 	= 	22;																	// конечное значение для счетчика (11.9.4 стр. 75)  	586/(22+1)~=25.5 Hz (39 ms)
	
	if ((PINB & (1<<BTN)) == 0)														// если при включении обнаружена нажатая кнопка
	{
		Flag_byte |= (1<<_setting_mode_on);											// установка флага режима настройки
		Delay_Pump_ON = 0;
	}
	else																			// в обычном режиме
	{	
		Delay_Pump_ON = eeprom_read_byte (& Delay_Pump_ON_EE);						// считывание данных с памяти EEPROM
	}
	
	asm ("sei");																	// разрешение прерываний (стр. 161)
}


	/**********************************************************************************************
	*                                         ПРЕРЫВАНИЯ                                          *
	**********************************************************************************************/

		/*--------------------------- По совпадению счетчика А ------------------------------*/

ISR (TIM0_COMPA_vect)																// 39 ms
{
	CountTime ++;																	// инкремент счетчики
	
	if (Flag_byte & (1<<_setting_mode_on))											// если активен режим настройки
	{
		if (Delay_Pump_ON < 255)
		Delay_Pump_ON ++;															// инкремент задержки (ограничение - max 255)
	}
}